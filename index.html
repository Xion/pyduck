<!DOCTYPE html>
<html>
	<head>
		<title>pyduck</title>
		
		<style type="text/css">
			body {
				margin: 0;
				font-family: serif;
				font-size: 13pt;
			}
			div#page {
				width: 720px;
				margin: 20px auto;
			}
			
			img#github_corner {
				position: absolute;
				border: 0 none;
				margin: 0;
				top: 0;
				right: 0;
			}
			
			header#title {
				font-size: 64pt;
			}

			hr {
				margin: 40px auto;
				width: 80%;
				height: 5px;
				background-color: #aaaaaa;
			}
			
			h1 {
				font-size: 23pt;
				font-weight: normal;
				text-align: left;
				margin-top: 30px;
			}
			h2 {
				font-size: 17pt;
				text-align: left;
			}
			
			ul {
				list-style: circle;
			}
			
			code {
				display: inline;
				background: none repeat scroll 0 0 #eeeeee;
				font-family: monospace;
				margin: 4px 0;
				padding-left: 2px;
				padding-right: 2px;
			}
			div#page > code {
				display: block;
				white-space: pre-line;
				font-size: 12pt;
				padding: 10px 15px;
				line-height: 1.2em;
				margin: 10px -20px;
				padding-left: 30px;
			}
			div#page > code span.indent {
				padding-left: 2em;
			}
		</style>
		<script type="text/javascript">
			window.onload = function() {
				var codeBlocks = document.querySelectorAll("div#page > code");
				for (var idx in codeBlocks) {
					if (codeBlocks.hasOwnProperty(idx)) {
						var cb = codeBlocks[idx];
						console.log(cb.innerHTML);
						cb.innerHTML = cb.innerHTML.replace(/&amp;tab;/g, "<span class='indent'></span>");
					}
				}
			}
		</script>
	</head>
	<body>
		<a href="http://github.com/Xion/pyduck">
			<img id="github_corner" alt="Fork me on GitHub" src="img/github-forkme-corner.png"/>
		</a>
		<div id="page">
			<header id="title">pyduck</header>
			
			<p><strong>pyduck</strong> is an utility framework for easier, more robust and effective usage
			of one of Python's defining language traits: <em>duck typing</em>. It enhances the Python language
			with several useful features.</p>
			<p>Source code and issue tracking for <strong>pyduck</strong> can be found on
				<a href="http://github.com/Xion/pyduck">GitHub</a>.</p>
				
			<h1>Features</h1>
			<ul>
				<li><strong>interfaces</strong> which do not need to be explicitly declared (similar to Go language)</li>
				<li>automatic <strong>interface/type checking</strong> for function arguments (<code>@expects</code>)</li>
				<li><strong>function overloading</strong> based on interfaces/types of arguments</li>
				<li>automatic interface/type checking for function return values (<code>@returns</code>)</li>
			</ul>
			
			<h1>Installing pyduck</h1>
			<p>Install using either <strong>pip</strong> or <strong>easy_install</strong>:</p>
			<code>pip install pyduck</code>
			<code>easy_install pyduck</code>
			<p>or -if you want the bleeding edge - download the latest version from
				<a href="http://github.com/Xion/pyduck">GitHub</a>:</p>
			<code>git clone git://github.com/Xion/pyduck.git
				cd pyduck
				python setup.py develop</code>
			This way you can <code>git pull</code> changes without having to run <strong>setup.py</strong> again.
			
			<hr noshade="true"/>
			
			<h1>Interfaces</h1>
			<p><strong>pyduck</strong> allows to define interfaces which specify a desired set of methods
				that we require for objects to expose. For example, we can introduce a <code>Serializer</code>
				interface, containing methods for loading and dumping objects from/to some external data format
				(such as JSON or YAML):</p>
			<code>from pyduck import Interface
				
				class Serializer(<strong>Interface</strong>):
				&tab;def load(fp): pass
				&tab;def loads(s): pass
				&tab;def dump(obj, fp): pass
				&tab;def dumps(obj): pass</code>
			<p>Once there, we can use it in code that is supposed to operate on such serializers:</p>
			<code>from pyduck import implements
				
				class Data(object):
				&tab;def __init__(self, serializer):
				&tab;&tab;if not <strong>implements(serializer, Serializer)</strong>:
				&tab;&tab;&tab;raise TypeError, "Invalid serializer"
				&tab;&tab;self._serializer = serializer
				&tab;# ...</code>
			<p>The trick is that object passed to <code>Data()</code> does <em>not</em> need to know anything
				about the <code>Serializer</code> interface. The <code>implements</code> test will check
				for actual methods (<code>load</code>, <code>loads</code>, <code>dump</code>
				and <code>dumps</code>) rather than any explicit declarations - unlike, for example,
				<a href="http://docs.python.org/library/abc.html">abstract base classes</a>.</p>
			<p>To be more specific: when it comes to deciding whether object implements an interface,
				<strong>pyduck</strong> will check:</p>
			<ul>
				<li>number of arguments</li>
				<li>arguments' kind (normal, variadic (<code>*args</code>) or keyword (<code>**kwargs</code>))</li>
				<li>whether they are optional or not</li>
			</ul>
				
			<h1>Validating arguments (<code>@expects</code>)</h1>
			<p>In the example above, an <code>if</code> is used to check whether argument given
				to <code>Data.__init__</code> implements desired interface. Such constructs generally look
				like boilerplate, and <strong>pyduck</strong> helps to eliminate them by offering
				the <code>@expects</code> decorator.</p>
			<code>from pyduck import expects
				
				class Data(object):
				&tab;<strong>@expects(Serializer)</strong>
				&tab;def __init__(self, serializer):
				&tab;&tab;self._serializer = serializer
				&tab;# ...</code>
			<p><code>@expects</code> allows to specify interfaces or types which function arguments are required
				to "fit" into. This translates into <code>implements</code> or <code>isinstance</code> checks when
				function is called. Should any of those checks fail, <code>pyduck.ArgumentError</code>
				(derived from <code>TypeError</code>) is raised.</p>
				
			<h1>Function overloading</h1>
			<p>In Python, it's quite common pattern to provide slightly different logic depending on arguments
				the function was called with:</p>
			<code># TODO: insert the as_json() example from the GitHub issue about overload()</code>
			<p>This is another case of boilerplate <code>if</code>s cluttering the function's code.
				To eliminate them, <strong>pyduck</strong> allows to split the function into distinct
				routines - each having appropriate <code>@expects</code> declaration - and then combine
				into single "overloaded" function:</p>
			<code># TODO: as_json() using @expects and overload()</code>
			<p>When such function is called, <strong>pyduck</strong> will check how well the <code>@expects</code> 
				declarations are matched against actual arguments. The call is then dispatched to version
				that "wins" the overload resolution.</p>
		</div>
	</body>
</html>
