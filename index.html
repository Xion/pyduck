<!DOCTYPE html>
<html>
	<head>
		<title>pyduck</title>
		
		<link rel="stylesheet" type="text/css" href="style.css" />
		
		<script type="text/javascript">
			// replacing &tab; "entity refs" with <span> that simulates indentation
			window.onload = function() {
				var codeBlocks = document.querySelectorAll("div#page > code");
				for (var idx in codeBlocks) {
					if (codeBlocks.hasOwnProperty(idx)) {
						var cb = codeBlocks[idx];
						cb.innerHTML = cb.innerHTML.replace(/&amp;tab;/g, "<span class='indent'></span>");
					}
				}
			}
		</script>
	</head>
	<body>
		<a href="http://github.com/Xion/pyduck">
			<img id="github_corner" alt="Fork me on GitHub" src="img/github-forkme-corner.png"/>
		</a>
		<div id="page">
			<header id="title">
				<img id="duck" alt="" title="A duck (since it quacks like a duck)" src="img/duck.png"/>
				pyduck
			</header>
			
			<p><strong>pyduck</strong> is an utility framework for easier, more robust and effective usage
			of one of Python's defining language traits: <em>duck typing</em>. It enhances the Python language
			with several useful features.</p>
			<p>Source code and issue tracking for <strong>pyduck</strong> can be found on
				<a href="http://github.com/Xion/pyduck">GitHub</a>.</p>
				
			<h1>Features</h1>
			<ul>
				<li><strong>interfaces</strong> which do not need to be explicitly declared (similar to Go language)</li>
				<li>automatic <strong>interface/type checking</strong> for function arguments (<code>@expects</code>)</li>
				<li><strong>function overloading</strong> based on interfaces/types of arguments</li>
				<li>automatic interface/type checking for function return values (<code>@returns</code>)</li>
			</ul>
			
			<h1>Installing pyduck</h1>
			<p>Install using either <strong>pip</strong> or <strong>easy_install</strong>:</p>
			<code>pip install pyduck</code>
			<code>easy_install pyduck</code>
			<p>or - if you want the bleeding edge - download the latest version from
				<a href="http://github.com/Xion/pyduck">GitHub</a>:</p>
			<code>git clone git://github.com/Xion/pyduck.git
				cd pyduck
				python setup.py develop</code>
			<p>This way you can <code>git pull</code> changes without having to run <strong>setup.py</strong> again.</p>
			
			<hr noshade="true"/>
			
			<h1>Interfaces</h1>
			<p><strong>pyduck</strong> allows to define interfaces which specify a desired set of methods
				that we require for objects to expose. For example, we can introduce a <code>Serializer</code>
				interface, containing methods for loading and dumping objects from/to some external data format
				(such as JSON or YAML):</p>
			<code><span class="gray">from pyduck import Interface</span>
				
				class Serializer(<strong>Interface</strong>):
				&tab;def load(fp): pass
				&tab;def loads(s): pass
				&tab;def dump(obj, fp): pass
				&tab;def dumps(obj): pass</code>
			<p>Once there, we can use it in code that is supposed to operate on such serializers:</p>
			<code><span class="gray">from pyduck import implements</span>
				
				class Data(object):
				&tab;def __init__(self, serializer):
				&tab;&tab;if not <strong>implements(serializer, Serializer)</strong>:
				&tab;&tab;&tab;raise TypeError, "Invalid serializer"
				&tab;&tab;self._serializer = serializer
				&tab;# ...</code>
			<p>The trick is that object passed to <code>Data.__init__</code> does <em>not</em> need to know anything
				about the <code>Serializer</code> interface. The <code>implements</code> test will check
				for actual methods (<code>load</code>, <code>loads</code>, <code>dump</code>
				and <code>dumps</code>) rather than any explicit declarations - unlike, for example,
				<a href="http://docs.python.org/library/abc.html">abstract base classes</a>.</p>
			<p>To be more specific: when it comes to deciding whether object implements an interface,
				<strong>pyduck</strong> will check:</p>
			<ul>
				<li>whether method of appropriate name exists</li>
				<li>number of its arguments</li>
				<li>arguments' kind (normal, variadic (<code>*args</code>) or keyword (<code>**kwargs</code>))</li>
				<li>whether they are optional or not</li>
			</ul>
				
			<h1>Validating arguments (<code>@expects</code>)</h1>
			<p>In the example above, an <code>if</code> is used to check whether argument given
				to <code>Data.__init__</code> implements desired interface. Such constructs generally look
				like boilerplate, and <strong>pyduck</strong> helps to eliminate them by offering
				the <code>@expects</code> decorator.</p>
			<code><span class="gray">from pyduck import expects</span>
				
				class Data(object):
				&tab;<strong>@expects(Serializer)</strong>
				&tab;def __init__(self, serializer):
				&tab;&tab;self._serializer = serializer
				&tab;# ...</code>
			<p><code>@expects</code> allows to specify interfaces or types which function arguments are required
				to "fit" into. This translates into <code>implements</code> or <code>isinstance</code> checks when
				function is called. Should any of those checks fail, <code>pyduck.ArgumentError</code>
				(derived from <code>TypeError</code>) is raised.</p>
				
			<h1>Function overloading</h1>
			<p>In Python, it's quite common pattern to provide slightly different logic depending on arguments
				the function was called with:</p>
			<code>def as_json(value):
			    &tab;if isinstance(value, basestring):
			    &tab;&tab;return '"%s"' % str(value)
			    &tab;if isinstance(value, list):
			    &tab;&tab;json_list = map(as_json, value)
			    &tab;&tab;return "[%s]" % str.join(",", json_list)
			    &tab;if isinstance(value, dict):
			    &tab;&tab;json_dict = dict( ((as_json(str(k)), as_json(v))
			    &tab;&tab;&tab;&tab;&tab;&tab;&tab;&tab;for k, v in value.iteritems()) )
			    &tab;&tab;json_dict_string = str.join(",",
			    &tab;&tab;&tab;&tab;&tab;&tab;&tab;&tab;("%s: %s" for k, v in json_dict.iteritems()))
			    &tab;&tab;return "{%s}" % json_dict_string
			    &tab;# etc.</code>
			<p>This is another case of boilerplate <code>if</code>s cluttering the function's code.
				To eliminate them, <strong>pyduck</strong> allows to split the function into distinct
				routines - each having appropriate <code>@expects</code> declaration - and then combine them
				into single "overloaded" function:</p>
			<code>@expects(basestring)
				def __string_as_json(value):
				&tab;return '"%s"' % str(value)
				
				@expects(list)
				def __list_as_json(value):
				&tab;json_list = map(as_json, value)
				&tab;return "[%s]" % str.join(",", json_list)
				
				@expects(dict)
				def __dict_as_json(value)
				&tab;json_dict = dict( ((as_json(str(k)), as_json(v))
			    &tab;&tab;&tab;&tab;&tab;&tab;&tab;for k, v in value.iteritems()) )
			    &tab;json_dict_string = str.join(",",
			    &tab;&tab;&tab;&tab;&tab;&tab;&tab;("%s: %s" for k, v in json_dict.iteritems()))
			    &tab;return "{%s}" % json_dict_string
			    
			    as_json = <strong>overload</strong>(__string_as_json, __list_as_json, __dict_as_json)</code>
			<p>When such function is called, <strong>pyduck</strong> will check how well the <code>@expects</code> 
				declarations are matched against actual arguments. The call is then dispatched to version
				that "wins" the overload resolution.</p>
				
			<h1>Validating return values (<code>@returns</code>)</h1>
			<p>To complement the <code>@expects</code> decorator, <strong>pyduck</strong> offers the
				<code>@returns</code> one. It can automatically verify whether function has returned an object
				of correct interface or type:</p>
			<code><span class="gray">from pyduck import returns</span>
				
				<strong>@returns(int)</strong>
				def get_random_number():
				&tab;return 4 # chosen by fair dice roll, guaranteed to be random</code>
			<p>While the verification is slightly less useful than the one performed by <code>@expects</code>,
				<code>@returns</code> serves well as a visual aid: it concisely informs the callers
				what they can expect for function to return. And in case changes in function code cause
				the <code>@returns</code> contract to break, <code>pyduck.ReturnValueError</code>
				(derived from <code>TypeError</code>) will be raised when returning from function call	.</p>
				
			<footer>&copy; Copyright 2011 <a href="http://github.com/Xion">Karol Kuczmarski</a></footer>
		</div>
	</body>
</html>
